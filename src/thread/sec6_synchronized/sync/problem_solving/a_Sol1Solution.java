package thread.sec6_synchronized.sync.problem_solving;

import thread.util.MyLogger;

import java.util.concurrent.atomic.AtomicInteger;

// ë‚˜ì˜ ì˜ˆìƒ
// ë¬¸ì œëŠ” ë‘ ìŠ¤ë ˆë“œê°€ í˜„ì¬ êµì°¨ë˜ë©° ì§„í–‰ë˜ê³  ìˆë‹¤
// ì—¬ëŸ¬ ì½”ì–´ê°€ ì •ë§ "ë™ì‹œì— count+=1" ì„ ìˆ˜í–‰í•˜ëŠ” êµ¬ê°„ìœ¼ë¡œ ëˆ„ë½ë˜ëŠ” ê²ƒ ê°™ë‹¤ (í•˜ë‚˜ê°€ ì €ì¥ì „ì— ì‹¤í–‰ë˜ë‹ˆ ê·¸ëƒ¥ ë‚ ë¼ê°€ëŠ” ê±°ì„)
// ê·¸ë¦¼ì„ ê·¸ë ¤ë³´ëŠ”ê²Œ ë§¤ìš° ì¤‘ìš”í•œë“¯!!
/*
  t1, t2 - ê°ì!!
  |           |
  | increment | - count ì˜ ê°’ì„ ì½ëŠ”ë‹¤ / ì½ì€ ê°’ì— 1 ë”í•œë‹¤ / ë”í•œ ê°’ì„ ì €ì¥í•œë‹¤ì˜ <3ê°€ì§€ ê³¼ì •>
  |    run    |

  >> ë‘ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— í™ ì˜ì—­ì˜ count ë¥¼ ì½ëŠ” ê·¸ë¦¼ ìƒê°! (ë‘ ìŠ¤ë ˆë“œê°€ ë™ì‹œì—! ì‹¤í–‰ëœë‹¤) --- ê·¼ë° ì•„ë§ˆ ì½”ë“œ í•œì¤„ì´ê¸° ë•Œë¬¸ì—, ë©€í‹°ì½”ì–´ë¼ì„œ ê°€ëŠ¥í•œ ìƒí™©ì´ë¼ê³  ìƒê°í•œë‹¤
  >> *increment í•¨ìˆ˜ì˜ í•œì¤„ì§œë¦¬ ì½”ë“œëŠ” ì„ê³„ ì˜ì—­ì„*
 */

/*
 ì´í›„ ì•Œê²Œ ëœ ê±´ë°, "ë©€í‹° ì½”ì–´"ë¼ì„œ ê°€ëŠ¥í•œ ìƒí™©ì´ì˜€ë˜ ê²ƒì´ ì•„ë‹ˆë‹¤!!!!!
 2ï¸âƒ£ ìŠ¤ë ˆë“œ ì „í™˜(TASK SWITCHING)ì´ count += 1 ë„ì¤‘ì— ë°œìƒí•  ìˆ˜ ìˆì„ê¹Œ?
    ë„¤, ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    ìš´ì˜ì²´ì œì˜ ìŠ¤ì¼€ì¤„ëŸ¬ëŠ” ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ë˜ëŠ” ë„ì¤‘ ì–¸ì œë“ ì§€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì „í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    (ìŠ¤ë ˆë“œ ì „í™˜ì€ ëª…ë ¹ì–´ ë‹¨ìœ„ë¡œ ì¼ì–´ë‚  ìˆ˜ë„ ìˆê³ , ëª…ë ¹ì–´ ì¼ë¶€ë§Œ ì‹¤í–‰ëœ ìƒíƒœì—ì„œ ë°”ë€” ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.)
    ì¦‰, count += 1ì€ í•œ ì¤„ì´ì§€ë§Œ, ì´ ì—°ì‚°ì´ CPU ë‹¨ì—ì„œ ì—¬ëŸ¬ ê°œì˜ ê¸°ê³„ì–´ ëª…ë ¹ì–´ë¡œ ë¶„í• ë˜ê¸° ë•Œë¬¸ì—
    ìŠ¤ë ˆë“œê°€ ì¤‘ê°„ì— ì „í™˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    !!!!!!!!!í•œ ì¤„ì´ë¼ê³  ì•ˆì „í•œê²Œ ì•„ë‹ˆë‹¤!!!!!!!!
    >> ê·¸ë˜ì„œ ì´ë¥¼ "ì›ìì„±"ì— ëŒ€í•œ ê´€ì ìœ¼ë¡œ ë³¸ë‹¤. Atomicity ê°€ ë³´ì¥ë˜ë©´, CPU ê°€ ê¸°ê³„ì–´ ëª…ë ¹ì–´ë¡œ ë¶„í• í•´ì„œ ìˆ˜í–‰í•˜ëŠ” í•œ ê³¼ì • ì¤‘ ë°©í•´ë°›ì§€ ì•Šê²Œ ë¬¼ë¦¬ì ìœ¼ë¡œ ì„¤ê³„ëœ ê²ƒì„ ë§í•œë‹¤

 ğŸ“Œ ì •ë¦¬í•˜ë©´?
    CPU ëª…ë ¹ì–´ 1ê°œë¡œ ì´ë£¨ì–´ì§„ ì—°ì‚°ì´ë©´ ì›ìì (Atomic)ì´ë‹¤.
    í•˜ì§€ë§Œ CPU ëª…ë ¹ì–´ê°€ ì—¬ëŸ¬ ê°œë¡œ ë¶„í• ë˜ë©´, ì›ìì„±ì´ ê¹¨ì§ˆ ìˆ˜ ìˆë‹¤.
    ì›ìì„±ì„ ë³´ì¥í•˜ë ¤ë©´ CAS(Compare-And-Swap) ê°™ì€ í•˜ë“œì›¨ì–´ ì§€ì›ì´ í•„ìš”í•˜ë‹¤.
    >> ë°©ë²• 1 : CAS ì—°ì‚° - HW ì§€ì›ì„ í†µí•œ, CPUì˜ CAS ì—°ì‚°ì„ ì§€ì›í•˜ëŠ” Library ì‚¬ìš© - AtomicInteger.incrementAndGet() ë”°ìœ„ - CPU ë‹¨ì—ì„œ ë‹¨ì¼ ëª…ë ¹ì–´ë¡œ ìˆ˜í–‰ë¨
    >> ë°©ë²• 2 : ì´ ë¬¸ì œ ì†”ë£¨ì…˜ì²˜ëŸ¼, sync ì‚¬ìš©
    >> ë°©ë²• 3 : ì§ì ‘ ë½ì„ ì œì–´í•˜ì—¬ ì‚¬ìš©

 */

public class a_Sol1Solution {

    public static void main(String[] args) throws InterruptedException {

//        Counter counter = new Counter();
        CASCounter counter = new CASCounter();

        Runnable task = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10000; i++) {
                    counter.increment();
                }
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        MyLogger.log("[ê²°ê³¼í™•ì¸]: " + counter.getCount());
    }

    // TIP :: ë©”ëª¨ë¦¬ ê°€ì‹œì„± ë¬¸ì œë„ ìƒê¸°ì§€ë§Œ, Sync ë•ë¶„ì— ìì—°ìŠ¤ëŸ½ê²Œ í•´ê²°ë¨ì„ ì¸ì§€ (Sync í•˜ë©´ ìƒˆë¡œ ê°€ì ¸ì˜´)
    static class Counter {
        private int count = 0;

        public synchronized void increment() {
            count += 1;
        }

        public int getCount() {
            return count;
        }
    }

    // ë‚´ê°€ ìƒê°í•œ ë˜ë‹¤ë¥¸ ë°©ë²•
    static class CASCounter {
        private AtomicInteger count = new AtomicInteger(0);

        public void increment() {
            count.incrementAndGet(); // âœ… ë‚´ë¶€ì ìœ¼ë¡œ CAS ì—°ì‚° ìˆ˜í–‰ (ì›ìì„± ë³´ì¥)
        }

        public int getCount() {
            return count.get();
        }
    }
}
